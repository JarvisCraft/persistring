# persistring

## Пётр Портнов, ИУ8-55

Набор реализаций персистентных строк.

## Теоретическая часть

### Персистентные структуры данных

Под персистентными структурами данных подразумеваются, как правило, такие структуры данных, которые при операциях, изменяющих их состояние, сохраняют доступ к предыдущим версиям.

### Персистентные строки

В качестве персистентной строки будем рассматривать некоторую строку, которая предоставляет набор изменяющих (мутирующих) операций, а также пару методов версиирования:

- `undo()`: переводит строку в предыдущее состояние, если это состояние не является начальным, при этом, запоминая и череду отменённых последующих состояний
- `redo()`: восстанавливает строку в ранее отменённое состояние, если это состояние не является последним

При этом, изменение строки, находящейся не в последнем состоянии, затирает всю предыдущую историю последующих состояний (такие состояние можно назвать недостижимыми), например:

```rust
string.push_str("foo"); // "foo"
string.push_str("bar"); // "foobar"
string.undo(); // "foo", состояние "foobar" достижимо вызовом `redo()`
string.push_str("baz"); // "foobaz", состояние "foobar" более недостижимо
```

Последнее ограничение отличается от общего определения персистентных структур данных, которое требует обязательного доступа к **любой** версии.

### Подходы к реализации

Наиболее простым подходом является хранение последовательных состояний данной структуры данных (в нашем случае, строки), например (при данных условиях) в стеке. Этот подход является наиболее простым в исполнении, но является одним из наиболее требовательных с точки зрения памяти.

Другим универсальным подходом является хранение вместо версий набора изменений, приводящим к ним. Данный подход является значительно более дешёвым с точки зрения памяти, однако вычисление текущего состояние может быть дорогостоющей операцией.

Более интересные подходы к выполнению могут основываться на особенностях конкретных структур данных. Так, за счёт линейности строки, можно реализовать её персистентную версию, гибрид из двух предыдущих, которая хранит "в горячем доступе" (например, на вершине стека) набор текущих своих составляющих (истории компонентов), при этом оставляя эти составляющие в неизменном виде при изменениях в других частях.

Например, последовательность операций вида:

```rust
string.push_str("foo");
string.push_str("bar");
string.push_str("baz");
string.push_at(6, "foo");
```

Этот подход можно описать, например, таблицей вроде:

| Версия строки \ Индекс истории компонента | 0    | 1    | 2    | 4    |
| ----------------------------------------- | ---- | ---- | ---- | ---- |
| 0                                         |      |      |      |      |
| 1                                         | foo  |      |      |      |
| 2                                         |      | bar  |      |      |
| 3                                         |      |      | ba   | z    |
| 4                                         |      |      | qux  |      |

Результирующая строка для представленной таблица: "foobarquxz".

При этом, однако, требуется более сложная логика поддержания таблицы в корректном

## Инструкция по использованию

Крейт предоставляется как библиотека, таким образом для использования, необходимо указать его в `Cargo.toml`, например следующим образом:

```toml
[dependencies]
persistring = "0.1.0"
```

Все персистентные строки реализуют типаж `PersistentString`, каждую из них можно создать вызовом метода `::new()`, например `CowPersistentString::new()`.

`PersistentString` описан следующим образом:

```rust
pub trait PersistentString {
    // Операции проверки состояния
    fn is_empty(&self) -> bool;
    fn len(&self) -> usize;
    // Получение текущего состояния
    fn snapshot(&self) -> Cow<str>;
    // Мутирующие операции
    fn push_str(&mut self, string: &str);
    fn repeat(&mut self, times: usize);
    // Операции "персистентности"
    fn undo(&mut self) -> Result<(), UndoError>;
    fn undo_n(&mut self, times: usize) -> Result<(), UndoError>;
    fn redo(&mut self) -> Result<(), RedoError>;
    fn redo_n(&mut self, times: usize) -> Result<(), RedoError>;
}
```

Планируется добавление других персистентных операций.

### Использование альтернативного аллокатора

При необходимости, есть возможность переопределить аллокатор у персистентных строк.

Поскольку, данная функциональность зависит от nightly API [`allocator_api`](https://doc.rust-lang.org/beta/unstable-book/library-features/allocator-api.html), для её включения необходимо:

1. использовать nightly-версию Rust, например:

   ```shell
   rustup override set nightly
   ```

2. включить одноимённую функциональность у зависимости, например:

   ```toml
   [dependencies]
   persistring = { version = "0.1.0", features = ["allocator_api"]}
   ```

## Описание реализаций

В настоящий момент, доступно две реализации `PersistentString`:

### `CowPersistentString`

> Здесь и далее используется стандартная реализация стека, `VecDeque`, основанная на расширяющемся (динамическом) массиве (векторе), поддерживающая:
>
> - индексацию за $O(1)$
> - вставку в вершину (амортизированно) за $O(1)$) (индивидуальная операция может выполняться за $O(n)$, однако оценивается множество подобных операций)
> - удаление из вершины за $O(1)$

Тривиальная реализация персистентной структуры данных. Основана на поддержании стека состояний (версий) и номера версии (индексируется с `1`, `0` соответствует отсутствию изменений относительно пустой строки) согласно следующим правилам:

- вырожденные случаи:
  - стек версий пуст: изначальная (пустая) строка; операция `undo()` недоступна
  - номер версии совпадает с размером стека версий: строка в последнем состоянии; операция `redo()` недоступна
- немутирующие операции читают значние стека, соответствующее текущей версии (не обязательно верхушку)
  - сложность операции по времени совпадает с асимптотической сложностью соответствующей операций на фиксированной строке
    - `is_empty()`, `len()`: $O(1)$
- мутирующие операции: записывают в стек новое состояние на одно выше, относительно текущего; при этом, если выше есть $l$ версий, то они удаляются (этот шаг не является обязательным, но позволяет освободить память, необходимую для поддержания "снимков" более ненужных версий):
  - сложность операции при длине текущей версии $n$ складывается из сложности самой операций (с учётом сложности создания результирующей строки длины), и, в худшем случае, времени реаллокации стека при текущем числе версий равном $s$ (последним можно принебречь, поскольку амортизированная сложность вставки в стек с сопоставима с $O(1)$, как указано выше):
    - `push_str(suffix: &str)`: $O(n + m + l)$, где $m$ - длина суффикса
    - `repeat(times: usize)`: $O(n \cdot times + l)$
- операция `undo()` уменьшает номер версии, при этом не изменяя стек версий, за счёт чего её сложность по времени: $O(1)$
- операция `redo()` увеличивает номер версии, при этом не изменяя стек версий, за счёт чего её сложность по времени: $O(1)$
- доступ к текущему состоянию (`snapshot()`) не требует копирования и пересборки строки, за счёт чего его сложность по времени: $O(1)$

Таким образом, данная структура данных выполняет строковые операции за время, сопоставимое со временем выполнения этих операций на "обычных" строках.

В это же время, данная структура данных является худшей по памяти, а именно требует хранения стека всех версий строки, независимо от взаимосвязей соседних строк. Сложность по памяти складывается из размеров всех состояний $O(\sum_{i=1}^k n_i) = O(k \cdot max_i n_i)$, где $k$ - число доступных версий, $n_i$ - длина i<sup>ой</sup> версии строки. 

### `DeltaPersistentString`

Альтернативный способ реализовать строку на основе единственного стека подразумевает хранение изменений ("дельт") вместо версий.

Дельта представляет из себя отличимую операцию и её параметры:

```rust 
enum Delta {
    PushStr(String),
    Repeat(usize),
    ...
}
```

и предоставляет метод применения её к некоторой строке:

```rust
fn apply(&self, mut string: String) -> String { ... }
```

С одной стороны, этот подход значительно уменьшает потребление памяти. С другой стороны, доступ к текущему состоянию требует вычисления результирующей строки.

Сложность по времени для построения строки на основе $r$  последовательных дельт: $O(\sum_{i=1}^r d_i) = O(r \cdot max_i d_i)$, где $d_i$ - время выполнения операции на данном шаге.

- вырожденные случаи:
  - стек дельт пуст: изначальная (пустая) строка; операция `undo()` недоступна
  - номер версии совпадает с размером стека дельт: строка в последнем состоянии; операция `redo()` недоступна
- немутирующие операции требует вычисления результрующей строки, откуда их сложность по времени:
  - `is_empty()`, `len()`: $O(r \cdot max_i d_i)$
- мутирующие операции добавляют дельты в стек, при этом инкрементируя номер текущей версии и, предпочтительно, удаляя $l$ недостижимых версий; при этом они не требуют создания новой строки, однако, в случае если данная дельта в качестве параметра содержит другую строку, можетбыть необходимо копирование последней (по аналогии с `CowPersistentString`, слагаемым $l$ можно принебречь):
  - `push_str(prefix: &str)`: $O(m + l)$, где $m$ - длина суффикса, который необходимо сохранить
  - `repeat(times: usize)`: $O(l)$

- операция `undo()` уменьшает номер версии, при этом не изменяя стек дельт, за счёт чего её сложность по времени: $O(1)$
- операция `redo()` увеличивает номер версии, при этом не изменяя стек дельт, за счёт чего её сложность по времени: $O(1)$
- доступ к текущему состоянию (`snapshot()`) требует пересборки строки, за счёт чего его сложность по времени: $O(r \cdot max_i d_i)$

Поддержание этой структуры обходится по памяти в $O(\sum_{i=1}^r p_i) = O(r \cdot max_i(p_i))$, где $p_i$ - память, необходимая для описания данной дельты.

Данная структура данных даёт значительное преимущество по памяти по сравнению со структурой, основанной на храненнии состояний, однако требует дорогостоющего вычисления текущего значения, за счёт прохода всей "истории", приводящей к этому состоянию.

#### Возможные оптимизации

Возможно реализовать механизм кэширования текущего состояния, а именно поддерживать опциональное поле, хранящее текущую версию, которое:

- вычисляется при необходимости
- инвалидируется при любой мутирующей операции, при операции `undo()`, при операции `redo()`

## Запланированные реализации

Планируется также реализовать персистентную строку, основанную 

## Описание тестов

Набор тестов (test suite) представлен в модуле [`tests`](./src/tests) и содержит следующий набор стандартных тестов для реализаций:

-  `test_push_with_undo`: тривиальный тест на корректность базовой операции изменения текста (`push_str`) и `undo` относительно неё
- `test_push_with_many_undo`: усложнённая версия предыдущего теста, проверяющая корректность перезаписывающих операций (`push_str` после `undo`)
- `test_push_with_many_undo_and_redo`: тестирование корректности операций версиирования (`undo`, `redo`) относительно `push_str`
- `test_repeat`: тестирование операции мультиплицирования текста (`repeat`) вместе с `undo` и `redo`

